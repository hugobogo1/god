<!DOCTYPE html>
<html>
<head>
    <title>Paintball FPS - Pro Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background: linear-gradient(135deg, #0a0a0a, #1a1a2e); font-family: 'Courier New', monospace; overflow: hidden; }
        #gameContainer { position: relative; width: 1000px; height: 700px; background: linear-gradient(to bottom, #0f0f1a, #1a1a2e); border: 3px solid #00FF00; overflow: hidden; box-shadow: 0 0 40px rgba(0, 255, 0, 0.3), inset 0 0 40px rgba(0, 255, 0, 0.1); }
        #wave { position: absolute; top: 20px; left: 20px; color: #00FF00; font-size: 18px; font-weight: bold; text-shadow: 0 0 10px #00FF00, 0 0 20px rgba(0, 255, 0, 0.5); z-index: 100; background: rgba(0, 30, 0, 0.8); padding: 12px 18px; border: 2px solid #00FF00; border-radius: 8px; box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.2); }
        #kills { position: absolute; top: 80px; left: 20px; color: #FFD700; font-size: 16px; font-weight: bold; text-shadow: 0 0 10px #FFD700; z-index: 100; background: rgba(30, 25, 0, 0.8); padding: 10px 15px; border: 2px solid #FFD700; border-radius: 8px; box-shadow: inset 0 0 8px rgba(255, 215, 0, 0.2); }
        #weapon { position: absolute; top: 140px; left: 20px; color: #FF6B9D; font-size: 14px; font-family: monospace; text-shadow: 0 0 10px #FF6B9D; z-index: 100; background: rgba(30, 10, 20, 0.8); padding: 10px 15px; border: 2px solid #FF6B9D; border-radius: 8px; box-shadow: inset 0 0 8px rgba(255, 107, 157, 0.2); }
        canvas { display: block; background: linear-gradient(to bottom, #1a1a2e, #0a0a0a); filter: brightness(1.05); }
        #hud { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .stat { position: absolute; font-size: 16px; font-weight: bold; text-shadow: 0 0 10px #00FF00; font-family: 'Courier New', monospace; }
        #score { top: 20px; left: 240px; color: #00FF00; background: rgba(0, 30, 0, 0.8); padding: 12px 18px; border: 2px solid #00FF00; border-radius: 8px; box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.2); }
        #health { top: 20px; right: 20px; color: #FF4444; background: rgba(40, 0, 0, 0.8); padding: 12px 18px; border: 2px solid #FF4444; border-radius: 8px; text-shadow: 0 0 15px #FF4444, 0 0 25px rgba(255, 0, 0, 0.4); box-shadow: inset 0 0 10px rgba(255, 0, 0, 0.2); }
        #ammo { bottom: 20px; right: 20px; color: #00CCFF; background: rgba(0, 20, 40, 0.8); padding: 12px 18px; border: 2px solid #00CCFF; border-radius: 8px; text-shadow: 0 0 15px #00CCFF; box-shadow: inset 0 0 10px rgba(0, 204, 255, 0.2); }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 50px; height: 50px; z-index: 100; }
        .cross-line { position: absolute; background: #00FF00; box-shadow: 0 0 5px #00FF00; }
        .cross-h { width: 20px; height: 1px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .cross-v { width: 1px; height: 20px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .cross-corner { position: absolute; width: 8px; height: 8px; border: 2px solid #00FF00; box-shadow: 0 0 5px #00FF00; }
        .tl { top: 0; left: 0; border-right: none; border-bottom: none; }
        .tr { top: 0; right: 0; border-left: none; border-bottom: none; }
        .bl { bottom: 0; left: 0; border-right: none; border-top: none; }
        .br { bottom: 0; right: 0; border-left: none; border-top: none; }
        .cross-dot { position: absolute; width: 4px; height: 4px; background: #00FF00; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 8px #00FF00; border-radius: 50%; }
        #instructions { position: absolute; bottom: 8px; left: 8px; color: #00FF00; font-size: 11px; text-shadow: 0 0 5px #00FF00; font-family: monospace; z-index: 100; background: rgba(0, 20, 0, 0.7); padding: 6px 10px; border-radius: 4px; border: 1px solid rgba(0, 255, 0, 0.5); }
        #minimap { position: absolute; bottom: 20px; left: 20px; width: 150px; height: 150px; border: 2px solid #00FF00; background: rgba(0, 20, 0, 0.95); margin-bottom: 80px; z-index: 99; box-shadow: 0 0 20px rgba(0, 255, 0, 0.5), inset 0 0 15px rgba(0, 255, 0, 0.15); }
        #hitMarker { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 50px; height: 50px; border: 3px solid #FF0000; pointer-events: none; opacity: 0; z-index: 50; box-shadow: 0 0 15px #FF0000; transition: opacity 0.2s; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.98); color: #00FF00; padding: 60px; border-radius: 15px; text-align: center; display: none; z-index: 200; min-width: 450px; border: 3px solid #00FF00; box-shadow: 0 0 60px rgba(0, 255, 0, 0.6), inset 0 0 30px rgba(0, 255, 0, 0.1); }
        #gameOver h1 { font-size: 72px; margin-bottom: 20px; color: #FF4444; text-shadow: 0 0 30px #FF4444, 0 0 60px rgba(255, 0, 0, 0.5); letter-spacing: 4px; font-weight: bold; }
        #gameOver p { font-size: 32px; margin-bottom: 40px; color: #00FF00; text-shadow: 0 0 20px #00FF00; font-weight: bold; }
        #gameOver button { padding: 18px 50px; font-size: 26px; background: linear-gradient(135deg, #00FF00, #00DD88); color: #000; border: 3px solid #00FF00; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 0 25px rgba(0, 255, 0, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.2); font-family: 'Courier New', monospace; }
        #gameOver button:hover { background: linear-gradient(135deg, #00FFFF, #00FF88); transform: scale(1.08); box-shadow: 0 0 40px rgba(0, 255, 255, 0.7), inset 0 0 15px rgba(255, 255, 255, 0.3); }
        #gameOver button:active { transform: scale(0.95); }
        #waveTransition { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); color: #00FF00; padding: 40px; border-radius: 15px; text-align: center; display: none; z-index: 150; border: 3px solid #00FF00; box-shadow: 0 0 50px rgba(0, 255, 0, 0.6); font-size: 48px; font-weight: bold; text-shadow: 0 0 20px #00FF00; letter-spacing: 2px; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        <div id="hud">
            <div id="wave">üåä Wave: 1 | Enemies: 0/3</div>
            <div id="kills">‚ö° Killstreak: 0</div>
            <div id="weapon">üî´ Rifle [30 dmg]</div>
            <div id="score">üíé Score: 0</div>
            <div id="health">‚ù§ Health: 100/100</div>
            <div id="ammo">üì¶ Ammo: 300/300</div>
            <div id="crosshair">
                <div class="cross-line cross-h"></div>
                <div class="cross-line cross-v"></div>
                <div class="cross-corner tl"></div>
                <div class="cross-corner tr"></div>
                <div class="cross-corner bl"></div>
                <div class="cross-corner br"></div>
                <div class="cross-dot"></div>
            </div>
            <div id="instructions">WASD=Move | Mouse=Aim | Click=Shoot | 1-3=Weapons | R=Reload | SHIFT=Sprint | CTRL=Crouch | ESC=Pause</div>
            <canvas id="minimap"></canvas>
            <div id="hitMarker"></div>
            <div id="waveTransition"></div>
        </div>
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <p id="finalScore">Final Score: 0</p>
            <p id="finalWave" style="font-size: 24px; margin-bottom: 20px; color: #FFD700;">Waves Survived: 1</p>
            <button onclick="location.reload()">RESTART GAME</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = 1000, GAME_HEIGHT = 700, FOV = Math.PI / 3, MAX_DEPTH = 20, WALL_HEIGHT = 300;

        let player = { x: 5.5, y: 5.5, angle: 0, health: 100, maxHealth: 100, ammo: 300, maxAmmo: 300, recoil: 0, accuracy: 1, velocity: { x: 0, y: 0 }, screenShake: 0, isSprinting: false, isCrouching: false, currentWeapon: 0, kills: 0, killstreak: 0, weapons: [{ name: 'Rifle', damage: 30, rof: 600, accuracy: 0.85, ammo: 300, spread: 0.08, icon: 'üî´' }, { name: 'Shotgun', damage: 80, rof: 100, accuracy: 0.6, ammo: 50, spread: 0.25, icon: 'üî±' }, { name: 'Sniper', damage: 100, rof: 60, accuracy: 0.98, ammo: 20, spread: 0.01, icon: 'üéØ' }] };
        let gameActive = true, score = 0, enemies = [], lastShot = 0, mouseX = 500, waveNumber = 1, waveActive = false, waveEnemiesSpawned = 0, waveEnemiesDefeated = 0, powerUps = [], particles = [];

        const levelMap = [[1,1,1,1,1,1,1,1,1,1], [1,0,0,1,0,0,1,0,0,1], [1,0,0,1,0,0,1,0,0,1], [1,1,0,1,1,0,1,1,0,1], [1,0,0,0,0,0,0,0,0,1], [1,0,0,1,0,0,1,0,0,1], [1,0,0,1,0,0,1,0,0,1], [1,1,0,1,1,0,1,1,0,1], [1,0,0,0,0,0,0,0,0,1], [1,1,1,1,1,1,1,1,1,1]];

        const keys = {};
        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'Escape') { gameActive = !gameActive; if(!gameActive) document.getElementById('waveTransition').textContent = 'PAUSED'; else document.getElementById('waveTransition').style.display = 'none'; }
            if (e.key.toLowerCase() === 'r' && gameActive) { player.ammo = player.weapons[player.currentWeapon].ammo; updateAmmoDisplay(); createParticles(500, 350, 'üí•', 15); }
            if (e.key === 'Shift') player.isSprinting = true;
            if (e.key === 'Control') player.isCrouching = true;
            if (['1','2','3'].includes(e.key)) { player.currentWeapon = parseInt(e.key) - 1; updateWeaponDisplay(); createParticles(150, 650, '‚öî', 8); }
        });
        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            if (e.key === 'Shift') player.isSprinting = false;
            if (e.key === 'Control') player.isCrouching = false;
        });
        document.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            if (gameActive) player.angle += ((mouseX - GAME_WIDTH / 2) * 0.005);
        });
        canvas.addEventListener('click', shoot);

        function createParticles(x, y, emoji, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x, y: y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4 - 1,
                    emoji: emoji, life: 1, opacity: 1
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx; particles[i].y += particles[i].vy;
                particles[i].vy += 0.15; particles[i].life -= 0.02; particles[i].opacity -= 0.02;
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function renderParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.opacity;
                ctx.font = '20px Arial';
                ctx.fillText(p.emoji, p.x, p.y);
                ctx.globalAlpha = 1;
            });
        }

        function isWall(x, y) { const mapX = Math.floor(x), mapY = Math.floor(y); return mapX < 0 || mapX >= 10 || mapY < 0 || mapY >= 10 || levelMap[mapY][mapX] === 1; }

        function movePlayer() {
            if (!gameActive) return;
            player.velocity.x *= 0.85; player.velocity.y *= 0.85;
            let accelX = 0, accelY = 0, speedBoost = player.isSprinting ? 1.5 : 1;
            if (keys['w']) { accelX += Math.cos(player.angle) * 0.008 * speedBoost; accelY += Math.sin(player.angle) * 0.008 * speedBoost; }
            if (keys['s']) { accelX -= Math.cos(player.angle) * 0.008; accelY -= Math.sin(player.angle) * 0.008; }
            if (keys['a']) { accelX += Math.cos(player.angle - Math.PI / 2) * 0.008 * speedBoost; accelY += Math.sin(player.angle - Math.PI / 2) * 0.008 * speedBoost; }
            if (keys['d']) { accelX += Math.cos(player.angle + Math.PI / 2) * 0.008 * speedBoost; accelY += Math.sin(player.angle + Math.PI / 2) * 0.008 * speedBoost; }
            player.velocity.x += accelX; player.velocity.y += accelY;
            let newX = player.x + player.velocity.x, newY = player.y + player.velocity.y;
            if (!isWall(newX, newY)) { player.x = newX; player.y = newY; } else { player.velocity.x = 0; player.velocity.y = 0; }
            player.recoil *= 0.92; player.accuracy = Math.min(1, player.accuracy + 0.02);
            if (player.isSprinting) player.accuracy *= 0.6;
            if (player.isCrouching) player.accuracy *= 1.3;
        }

        function castRay(angle) {
            let x = player.x, y = player.y, distance = 0;
            while (distance < MAX_DEPTH) { x += Math.cos(angle) * 0.05; y += Math.sin(angle) * 0.05; distance += 0.05; if (isWall(x, y)) return distance; }
            return MAX_DEPTH;
        }

        function normalizeAngle(angle) { while (angle > Math.PI) angle -= 2 * Math.PI; while (angle < -Math.PI) angle += 2 * Math.PI; return angle; }

        function render3D() {
            ctx.fillStyle = '#2a3a4e'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT / 2);
            ctx.fillStyle = '#0a0a1a'; ctx.fillRect(0, GAME_HEIGHT / 2, GAME_WIDTH, GAME_HEIGHT / 2);
            ctx.strokeStyle = 'rgba(100, 150, 180, 0.2)'; ctx.lineWidth = 1;
            for (let i = 0; i < GAME_WIDTH; i += 50) { ctx.beginPath(); ctx.moveTo(i, GAME_HEIGHT / 2); ctx.lineTo(i, GAME_HEIGHT); ctx.stroke(); }

            const numRays = GAME_WIDTH, rayAngleStep = FOV / numRays;
            for (let i = 0; i < numRays; i++) {
                const rayAngle = player.angle - FOV / 2 + rayAngleStep * i;
                const distance = castRay(rayAngle);
                const correctedDistance = distance * Math.cos(rayAngle - player.angle);
                const wallHeight = Math.min(WALL_HEIGHT / (correctedDistance + 0.1), GAME_HEIGHT);
                const brightness = Math.floor(200 - (distance / MAX_DEPTH) * 120);
                const color = `rgb(${brightness}, ${Math.floor(brightness * 0.7)}, ${Math.floor(brightness * 0.5)})`;
                ctx.fillStyle = color; ctx.fillRect(i, (GAME_HEIGHT - wallHeight) / 2, 1, wallHeight);
                ctx.fillStyle = `rgba(0, 0, 0, ${0.05 + (distance / MAX_DEPTH) * 0.15})`; ctx.fillRect(i, (GAME_HEIGHT - wallHeight) / 2, 1, wallHeight);
            }

            enemies.forEach(enemy => {
                const dx = enemy.x - player.x, dy = enemy.y - player.y, enemyDist = Math.sqrt(dx * dx + dy * dy);
                const enemyAngle = Math.atan2(dy, dx), angleDiff = normalizeAngle(enemyAngle - player.angle);
                if (Math.abs(angleDiff) < FOV / 2 && enemyDist < MAX_DEPTH) {
                    const screenX = GAME_WIDTH / 2 + (angleDiff / (FOV / 2)) * (GAME_WIDTH / 2);
                    const enemyHeight = Math.min(WALL_HEIGHT / (enemyDist + 0.1), GAME_HEIGHT);
                    const enemyTop = (GAME_HEIGHT - enemyHeight) / 2, enemyWidth = enemyHeight * 0.6;
                    ctx.fillStyle = enemy.color + '60'; ctx.shadowBlur = 15; ctx.shadowColor = enemy.color; ctx.fillRect(screenX - enemyWidth / 2 - 15, enemyTop - 15, enemyWidth + 30, enemyHeight + 30);
                    ctx.fillStyle = enemy.color; ctx.shadowBlur = 20; ctx.shadowColor = enemy.color; ctx.fillRect(screenX - enemyWidth / 2, enemyTop, enemyWidth, enemyHeight);
                    ctx.shadowBlur = 0;
                    enemy.paintHits.forEach(hit => {
                        ctx.fillStyle = hit.color; ctx.globalAlpha = 0.7; ctx.fillRect(screenX - enemyWidth / 2 + hit.x * enemyWidth - hit.size / 2, enemyTop + hit.y * enemyHeight - hit.size / 2, hit.size, hit.size); ctx.globalAlpha = 1;
                    });
                }
            });

            powerUps.forEach(p => {
                const dx = p.x - player.x, dy = p.y - player.y, dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx), angleDiff = normalizeAngle(angle - player.angle);
                if (Math.abs(angleDiff) < FOV / 2 && dist < MAX_DEPTH) {
                    const screenX = GAME_WIDTH / 2 + (angleDiff / (FOV / 2)) * (GAME_WIDTH / 2);
                    const size = Math.min(WALL_HEIGHT / (dist + 0.1), GAME_HEIGHT);
                    const top = (GAME_HEIGHT - size) / 2;
                    ctx.fillStyle = p.type === 'health' ? '#FF0000' : '#00FFFF';
                    ctx.shadowBlur = 15; ctx.shadowColor = p.type === 'health' ? '#FF0000' : '#00FFFF';
                    ctx.fillRect(screenX - size / 2, top, size, size);
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#FFF'; ctx.font = 'bold ' + Math.floor(size / 3) + 'px Arial'; ctx.textAlign = 'center'; ctx.fillText(p.type === 'health' ? '‚ù§' : 'üì¶', screenX, top + size / 2);
                }
            });

            if (player.screenShake > 0) { ctx.globalAlpha = player.screenShake * 0.1; ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); ctx.globalAlpha = 1; player.screenShake -= 0.05; }
        }

        function spawnEnemy() {
            waveEnemiesSpawned++;
            const spawnSides = [[1, Math.random() * 8 + 1], [9, Math.random() * 8 + 1], [Math.random() * 8 + 1, 1], [Math.random() * 8 + 1, 9]];
            const spawn = spawnSides[Math.floor(Math.random() * spawnSides.length)];
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
            enemies.push({
                x: spawn[0], y: spawn[1], health: 20 + (waveNumber * 5), maxHealth: 20 + (waveNumber * 5), speed: 0.02 + (waveNumber * 0.005),
                shootCooldown: 0, color: colors[Math.floor(Math.random() * colors.length)], paintHits: []
            });
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = player.x - enemy.x, dy = player.y - enemy.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0.1) { enemy.x += (dx / dist) * enemy.speed; enemy.y += (dy / dist) * enemy.speed; }
                enemy.shootCooldown -= 1;
                if (dist < 5 && enemy.shootCooldown <= 0) { enemy.shootCooldown = 60 + Math.random() * 40; }
                powerUps.forEach((p, pIdx) => { const pdx = p.x - player.x, pdy = p.y - player.y; if (Math.sqrt(pdx * pdx + pdy * pdy) < 0.3) { if (p.type === 'health') player.health = Math.min(player.maxHealth, player.health + 30); else player.ammo = player.weapons[player.currentWeapon].ammo; powerUps.splice(pIdx, 1); document.getElementById('health').textContent = '‚ù§ Health: ' + Math.max(0, Math.floor(player.health)); updateAmmoDisplay(); createParticles(500, 350, '‚ú®', 20); } });
                if (dist < 0.5) { player.health -= 2; document.getElementById('health').textContent = '‚ù§ Health: ' + Math.max(0, Math.floor(player.health)); if (player.health <= 0) gameOver(); }
                if (enemy.health <= 0) {
                    enemies.splice(i, 1); waveEnemiesDefeated++; score += 500 + (waveNumber * 100);
                    player.kills++; player.killstreak++; document.getElementById('score').textContent = 'üíé Score: ' + score;
                    document.getElementById('kills').textContent = `‚ö° Killstreak: ${player.killstreak}`;
                    createParticles(500, 350, 'üí•', 20);
                    if (Math.random() > 0.7) powerUps.push({ x: enemy.x, y: enemy.y, type: Math.random() > 0.5 ? 'health' : 'ammo', lifetime: 300 });
                }
            }
        }

        function shoot() {
            if (!gameActive || Date.now() - lastShot < 60000 / player.weapons[player.currentWeapon].rof || player.ammo <= 0) return;
            const weapon = player.weapons[player.currentWeapon];
            player.ammo--; player.screenShake = Math.max(player.screenShake, 0.5); updateAmmoDisplay();
            lastShot = Date.now(); player.recoil = Math.min(1, player.recoil + 0.3); player.accuracy *= 0.8;

            for (let i = enemies.length - 1; i >= 0; i--) {
                const dx = enemies[i].x - player.x, dy = enemies[i].y - player.y;
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle(angleToEnemy - player.angle));
                if (angleDiff < 0.2) {
                    const hitDist = Math.sqrt(dx * dx + dy * dy);
                    if (hitDist < MAX_DEPTH) {
                        const paintColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
                        const hitColor = paintColors[Math.floor(Math.random() * paintColors.length)];
                        enemies[i].paintHits.push({ x: Math.random(), y: Math.random(), size: 5, color: hitColor });
                        enemies[i].health -= weapon.damage; enemies[i].color = hitColor;
                        const hitMarker = document.getElementById('hitMarker');
                        hitMarker.style.opacity = '1'; setTimeout(() => { hitMarker.style.opacity = '0'; }, 200);
                        createParticles(500, 350, 'üéØ', 10);
                        break;
                    }
                }
            }
        }

        function updateAmmoDisplay() {
            const weapon = player.weapons[player.currentWeapon];
            document.getElementById('ammo').textContent = `üì¶ Ammo: ${player.ammo}/${weapon.ammo} | R: Reload`;
        }

        function updateWeaponDisplay() {
            const weapon = player.weapons[player.currentWeapon];
            document.getElementById('weapon').textContent = `${weapon.icon} ${weapon.name} [${weapon.damage} dmg]`;
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = 'Final Score: ' + score;
            document.getElementById('finalWave').textContent = 'Waves Survived: ' + waveNumber;
            console.log('Game Over - Score:', score, 'Wave:', waveNumber);
        }

        function startWave() {
            waveActive = true; waveEnemiesSpawned = 0; waveEnemiesDefeated = 0; player.killstreak = 0;
            const maxEnemies = 3 + (waveNumber * 2);
            document.getElementById('wave').textContent = `üåä Wave: ${waveNumber} | Enemies: 0/${maxEnemies}`;
            showWaveTransition();
        }

        function showWaveTransition() {
            const trans = document.getElementById('waveTransition');
            trans.textContent = `WAVE ${waveNumber}`;
            trans.style.display = 'block';
            setTimeout(() => { trans.style.display = 'none'; }, 2000);
        }

        function checkWaveComplete() {
            if (waveActive && waveEnemiesDefeated >= (3 + (waveNumber * 2))) {
                waveActive = false; waveNumber++;
                player.health = Math.min(player.maxHealth, player.health + 25);
                player.ammo = player.weapons[player.currentWeapon].ammo;
                document.getElementById('health').textContent = '‚ù§ Health: ' + Math.floor(player.health);
                updateAmmoDisplay(); score += 1000 * waveNumber;
                document.getElementById('score').textContent = 'üíé Score: ' + score;
                createParticles(500, 350, 'üéâ', 30);
            }
        }

        function update() {
            if (!gameActive) return;
            movePlayer(); updateEnemies(); updateParticles(); checkWaveComplete();
            if (!waveActive && enemies.length === 0) startWave();
        }

        function renderMinimap() {
            const minimapCanvas = document.getElementById('minimap');
            if (!minimapCanvas) return;
            const minimapCtx = minimapCanvas.getContext('2d');
            const mapScale = 15;
            minimapCtx.fillStyle = '#001a00'; minimapCtx.fillRect(0, 0, 150, 150);
            minimapCtx.fillStyle = '#003300'; minimapCtx.strokeStyle = '#004400'; minimapCtx.lineWidth = 1;
            for (let y = 0; y < 10; y++) for (let x = 0; x < 10; x++) if (levelMap[y][x] === 1) { minimapCtx.fillRect(x * mapScale, y * mapScale, mapScale, mapScale); minimapCtx.strokeRect(x * mapScale, y * mapScale, mapScale, mapScale); }
            minimapCtx.fillStyle = '#FF6B6B'; enemies.forEach(e => { minimapCtx.beginPath(); minimapCtx.arc(e.x * mapScale, e.y * mapScale, 3, 0, Math.PI * 2); minimapCtx.fill(); });
            powerUps.forEach(p => { minimapCtx.fillStyle = p.type === 'health' ? '#FFD700' : '#00CCFF'; minimapCtx.fillRect(p.x * mapScale - 2, p.y * mapScale - 2, 4, 4); });
            minimapCtx.fillStyle = '#00FF00'; minimapCtx.beginPath(); minimapCtx.arc(player.x * mapScale, player.y * mapScale, 4, 0, Math.PI * 2); minimapCtx.fill();
            minimapCtx.strokeStyle = '#00FF00'; minimapCtx.lineWidth = 2; minimapCtx.strokeRect(0, 0, 150, 150);
        }

        function gameLoop() {
            update(); render3D(); renderParticles(); renderMinimap();
            requestAnimationFrame(gameLoop);
        }

        let spawnInterval = setInterval(() => {
            if (gameActive && waveActive && enemies.length < (5 + waveNumber) && waveEnemiesSpawned < (3 + waveNumber * 2)) {
                spawnEnemy();
                document.getElementById('wave').textContent = `üåä Wave: ${waveNumber} | Enemies: ${waveEnemiesDefeated}/${3 + waveNumber * 2}`;
            }
        }, 1500 - Math.min(waveNumber * 100, 700));

        setTimeout(() => { if (gameActive) startWave(); }, 1000);

        gameLoop();
        console.log('‚úì PAINTBALL FPS PRO EDITION LOADED! WASD=Move, Click=Shoot, 1-3=Weapons, R=Reload, SHIFT=Sprint, CTRL=Crouch');
    </script>
</body>
</html>