<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paintball FPS - Wave Shooter</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background: #000; font-family: Arial, sans-serif; overflow: hidden; }
        #gameContainer { position: relative; width: 1000px; height: 700px; background: #000; border: 3px solid #444; overflow: hidden; }
        #wave { position: absolute; top: 60px; left: 20px; color: #00FF00; font-size: 20px; font-weight: bold; text-shadow: 0 0 10px #00FF00; z-index: 100; }
        #kills { position: absolute; top: 100px; left: 20px; color: #FF6600; font-size: 16px; font-weight: bold; text-shadow: 0 0 10px #FF6600; z-index: 100; }
        #weapon { position: absolute; top: 140px; left: 20px; color: #FFFF00; font-size: 14px; font-family: monospace; text-shadow: 0 0 5px #FFFF00; z-index: 100; }
        canvas { display: block; background: #000; }
        #hud { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .stat { position: absolute; font-size: 18px; font-weight: bold; text-shadow: 0 0 10px #00FF00; font-family: monospace; }
        #score { top: 20px; left: 20px; color: #00FF00; }
        #health { top: 20px; right: 20px; color: #FF0000; }
        #ammo { bottom: 20px; right: 20px; color: #FFD700; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 30px; z-index: 100; }
        .cross-line { position: absolute; background: #00FF00; }
        .cross-h { width: 12px; height: 2px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .cross-v { width: 2px; height: 12px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .cross-dot { position: absolute; width: 2px; height: 2px; background: #00FF00; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #instructions { position: absolute; bottom: 20px; left: 20px; color: #00FF00; font-size: 12px; text-shadow: 0 0 5px #00FF00; font-family: monospace; z-index: 100; }
        #minimap { position: absolute; bottom: 20px; left: 20px; width: 150px; height: 150px; border: 2px solid #00FF00; background: rgba(0, 20, 0, 0.8); margin-bottom: 80px; z-index: 99; }
        #hitMarker { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; border: 2px solid #FF0000; pointer-events: none; opacity: 0; z-index: 50; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); color: #00FF00; padding: 40px; border-radius: 10px; text-align: center; display: none; z-index: 200; min-width: 300px; border: 3px solid #00FF00; box-shadow: 0 0 30px #00FF00; }
        #gameOver h1 { font-size: 48px; margin-bottom: 20px; color: #FF0000; }
        #gameOver p { font-size: 24px; margin-bottom: 20px; color: #00FF00; }
        #gameOver button { padding: 10px 30px; font-size: 20px; background: #00FF00; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        #gameOver button:hover { background: #00FFFF; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        <div id="hud">
            <div id="score" class="stat">Score: 0</div>
            <div id="health" class="stat">‚ù§ Health: 100</div>
            <div id="ammo" class="stat">üì¶ Ammo: 300 | R: Reload</div>
            <div id="wave">üåä Wave: 1</div>
            <div id="kills">‚ö° Killstreak: 0</div>
            <div id="weapon">üî´ Weapon: Paintball Rifle [30 dmg, 600 RPM]</div>
            <canvas id="minimap"></canvas>
            <div id="hitMarker"></div>
            <div id="instructions">WASD: Move | SHIFT: Sprint | CTRL: Crouch | Mouse: Look | Click: Shoot | 1-3: Weapons</div>
            <div id="crosshair">
                <div class="cross-line cross-h"></div>
                <div class="cross-line cross-v"></div>
                <div class="cross-dot"></div>
            </div>
        </div>
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <p id="finalScore">Final Score: 0</p>
            <button onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <script>
        window.addEventListener('load', () => {
            console.log('‚úì Paintball FPS - Wave Shooter Loaded');
        });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = 1000, GAME_HEIGHT = 700, FOV = Math.PI / 3, MAX_DEPTH = 20, WALL_HEIGHT = 200;

        let player = { x: 5.5, y: 5.5, angle: 0, health: 100, maxHealth: 100, ammo: 300, maxAmmo: 300, recoil: 0, accuracy: 0, velocity: { x: 0, y: 0 }, screenShake: 0, isSprinting: false, isCrouching: false, currentWeapon: 0, kills: 0, killstreak: 0, weapons: [{ name: 'Rifle', damage: 30, rof: 600, accuracy: 0.85, ammo: 300, spread: 0.08, icon: 'üî´' }, { name: 'Shotgun', damage: 80, rof: 100, accuracy: 0.6, ammo: 50, spread: 0.25, icon: 'üî±' }, { name: 'Sniper', damage: 100, rof: 60, accuracy: 0.98, ammo: 20, spread: 0.01, icon: 'üéØ' }] };
        let gameActive = true, score = 0, enemies = [], lastShot = 0, mouseX = 500, waveNumber = 1, waveActive = false, waveEnemiesSpawned = 0, waveEnemiesDefeated = 0, powerUps = [], particles = [];

        const levelMap = [[1,1,1,1,1,1,1,1,1,1], [1,0,0,0,1,0,0,0,0,1], [1,0,0,0,1,0,1,0,0,1], [1,0,0,0,0,0,1,1,0,1], [1,0,1,1,0,0,0,1,0,1], [1,0,1,0,0,1,0,0,0,1], [1,0,0,0,1,1,0,0,1,1], [1,0,0,0,1,0,0,1,0,1], [1,0,0,0,0,0,0,0,0,1], [1,1,1,1,1,1,1,1,1,1]];

        const keys = {};
        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'Escape') gameActive = !gameActive;
            if (e.key.toLowerCase() === 'r') { player.ammo = player.weapons[player.currentWeapon].ammo; updateAmmoDisplay(); }
            if (e.key === 'Shift') player.isSprinting = true;
            if (e.key === 'Control') player.isCrouching = true;
            if (['1','2','3'].includes(e.key)) { player.currentWeapon = parseInt(e.key) - 1; updateWeaponDisplay(); }
        });
        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            if (e.key === 'Shift') player.isSprinting = false;
            if (e.key === 'Control') player.isCrouching = false;
        });
        document.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            if (gameActive) player.angle += ((mouseX - GAME_WIDTH / 2) * 0.005);
        });
        canvas.addEventListener('click', shoot);

        function isWall(x, y) { const mapX = Math.floor(x), mapY = Math.floor(y); return mapX < 0 || mapX >= 10 || mapY < 0 || mapY >= 10 || levelMap[mapY][mapX] === 1; }
        
        function movePlayer() {
            if (!gameActive) return;
            player.velocity.x *= 0.85; player.velocity.y *= 0.85;
            let accelX = 0, accelY = 0;
            if (keys['w']) { accelX += Math.cos(player.angle) * 0.008; accelY += Math.sin(player.angle) * 0.008; }
            if (keys['s']) { accelX -= Math.cos(player.angle) * 0.008; accelY -= Math.sin(player.angle) * 0.008; }
            if (keys['a']) { accelX += Math.cos(player.angle - Math.PI / 2) * 0.008; accelY += Math.sin(player.angle - Math.PI / 2) * 0.008; }
            if (keys['d']) { accelX += Math.cos(player.angle + Math.PI / 2) * 0.008; accelY += Math.sin(player.angle + Math.PI / 2) * 0.008; }
            player.velocity.x += accelX; player.velocity.y += accelY;
            let newX = player.x + player.velocity.x, newY = player.y + player.velocity.y;
            if (!isWall(newX, newY)) { player.x = newX; player.y = newY; } else { player.velocity.x = 0; player.velocity.y = 0; }
            player.recoil *= 0.92; player.accuracy *= 0.95;
            if (player.isSprinting) player.accuracy *= 0.7;
        }

        function castRay(angle) {
            let x = player.x, y = player.y, distance = 0;
            while (distance < MAX_DEPTH) { x += Math.cos(angle) * 0.05; y += Math.sin(angle) * 0.05; distance += 0.05; if (isWall(x, y)) return distance; }
            return MAX_DEPTH;
        }

        function normalizeAngle(angle) { while (angle > Math.PI) angle -= 2 * Math.PI; while (angle < -Math.PI) angle += 2 * Math.PI; return angle; }

        function render3D() {
            ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, GAME_HEIGHT / 2, GAME_WIDTH, GAME_HEIGHT / 2);
            ctx.strokeStyle = 'rgba(50, 50, 50, 0.4)'; ctx.lineWidth = 1;
            for (let i = 0; i < GAME_WIDTH; i += 50) { ctx.beginPath(); ctx.moveTo(i, GAME_HEIGHT / 2); ctx.lineTo(i, GAME_HEIGHT); ctx.stroke(); }

            const numRays = GAME_WIDTH, rayAngleStep = FOV / numRays;
            for (let i = 0; i < numRays; i++) {
                const rayAngle = player.angle - FOV / 2 + rayAngleStep * i;
                const distance = castRay(rayAngle);
                const correctedDistance = distance * Math.cos(rayAngle - player.angle);
                const wallHeight = Math.min(WALL_HEIGHT / (correctedDistance + 0.1), GAME_HEIGHT);
                const wallColor = Math.floor(150 - (distance / MAX_DEPTH) * 100);
                const color = `rgb(${wallColor}, ${wallColor * 0.8}, ${wallColor * 0.7})`;
                ctx.fillStyle = color;
                const wallTop = (GAME_HEIGHT - wallHeight) / 2;
                ctx.fillRect(i, wallTop, 1, wallHeight);
                if (i % 2 === 0) { ctx.fillStyle = `rgba(0, 0, 0, ${0.1 + (distance / MAX_DEPTH) * 0.2})`; ctx.fillRect(i, wallTop, 1, wallHeight); }
                ctx.fillStyle = '#0f0f1a'; ctx.fillRect(i, 0, 1, wallTop);
            }

            enemies.forEach(enemy => {
                const dx = enemy.x - player.x, dy = enemy.y - player.y, enemyDist = Math.sqrt(dx * dx + dy * dy);
                const enemyAngle = Math.atan2(dy, dx), angleDiff = normalizeAngle(enemyAngle - player.angle);
                if (Math.abs(angleDiff) < FOV / 2) {
                    const screenX = GAME_WIDTH / 2 + (angleDiff / (FOV / 2)) * (GAME_WIDTH / 2);
                    const enemyHeight = Math.min(WALL_HEIGHT / (enemyDist + 0.1), GAME_HEIGHT);
                    const enemyTop = (GAME_HEIGHT - enemyHeight) / 2, enemyWidth = enemyHeight * 0.6;
                    ctx.fillStyle = enemy.color + '40'; ctx.fillRect(screenX - enemyWidth / 2 - 10, enemyTop - 10, enemyWidth + 20, enemyHeight + 20);
                    ctx.fillStyle = enemy.color; ctx.fillRect(screenX - enemyWidth / 2, enemyTop, enemyWidth, enemyHeight);
                    enemy.paintHits.forEach(hit => {
                        ctx.fillStyle = hit.color; ctx.globalAlpha = 0.9;
                        ctx.beginPath(); ctx.arc(screenX - enemyWidth / 2 + hit.x * enemyWidth, enemyTop + hit.y * enemyHeight, hit.size, 0, Math.PI * 2);
                        ctx.fill(); ctx.globalAlpha = 1;
                    });
                    ctx.strokeStyle = enemy.color; ctx.lineWidth = 2; ctx.strokeRect(screenX - enemyWidth / 2, enemyTop, enemyWidth, enemyHeight);
                    ctx.fillStyle = '#440000'; ctx.fillRect(screenX - enemyWidth / 2, enemyTop - 20, enemyWidth, 8);
                    const healthPercent = (enemy.health / enemy.maxHealth) * 100;
                    ctx.fillStyle = healthPercent > 50 ? '#00FF00' : (healthPercent > 25 ? '#FFFF00' : '#FF0000');
                    ctx.fillRect(screenX - enemyWidth / 2, enemyTop - 20, (enemyWidth * healthPercent) / 100, 8);
                }
            });

            if (player.recoil > 0) {
                ctx.strokeStyle = `rgba(255, 200, 0, ${player.recoil * 0.5})`; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.arc(GAME_WIDTH / 2, GAME_HEIGHT / 2, 50 + player.recoil * 20, 0, Math.PI * 2); ctx.stroke();
            }
            if (player.screenShake > 0) {
                const shake = player.screenShake * 3; ctx.globalAlpha = player.screenShake * 0.2; ctx.fillStyle = '#FF0000';
                ctx.fillRect(-shake, -shake, GAME_WIDTH + shake * 2, GAME_HEIGHT + shake * 2); ctx.globalAlpha = 1;
                player.screenShake *= 0.9;
            }
        }

        function spawnEnemy() {
            if (!gameActive || enemies.length > (5 + waveNumber)) return;
            let x, y, valid = false, attempts = 0;
            while (!valid && attempts < 10) {
                x = Math.random() * 8 + 1; y = Math.random() * 8 + 1;
                valid = !isWall(x, y) && Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2) > 3; attempts++;
            }
            if (!valid) return;
            const paintColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
            const enemyColor = paintColors[Math.floor(Math.random() * paintColors.length)];
            enemies.push({ x, y, health: 100 + (waveNumber * 20), maxHealth: 100 + (waveNumber * 20), speed: 0.02 + (waveNumber * 0.005), shootCooldown: 40, color: enemyColor, paintHits: [] });
            waveEnemiesSpawned++;
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i], dx = player.x - enemy.x, dy = player.y - enemy.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0.5) { enemy.x += (dx / dist) * enemy.speed * 0.7; enemy.y += (dy / dist) * enemy.speed * 0.7; }
                enemy.shootCooldown--;
                if (dist < 6 && enemy.shootCooldown < 0) {
                    enemy.shootCooldown = 30 - Math.floor(waveNumber * 2);
                    player.health -= (3 + waveNumber); player.screenShake = 0.25;
                    document.getElementById('health').textContent = '‚ù§ Health: ' + Math.max(0, Math.floor(player.health));
                    if (player.health <= 0) gameOver();
                }
                if (dist < 0.5) { player.health -= 2; document.getElementById('health').textContent = '‚ù§ Health: ' + Math.max(0, Math.floor(player.health)); if (player.health <= 0) gameOver(); }
                if (enemy.health <= 0) {
                    enemies.splice(i, 1); waveEnemiesDefeated++; score += 500 + (waveNumber * 100);
                    player.kills++; player.killstreak++; document.getElementById('score').textContent = 'Score: ' + score;
                    document.getElementById('kills').textContent = `‚ö° Killstreak: ${player.killstreak}`;
                    if (Math.random() > 0.7) powerUps.push({ x: enemy.x, y: enemy.y, type: Math.random() > 0.5 ? 'health' : 'ammo', lifetime: 300 });
                }
            }
        }

        function shoot() {
            if (!gameActive || Date.now() - lastShot < 60000 / player.weapons[player.currentWeapon].rof || player.ammo <= 0) return;
            const weapon = player.weapons[player.currentWeapon];
            player.ammo--; player.screenShake = 0.3; updateAmmoDisplay();
            lastShot = Date.now(); player.recoil = Math.min(1, player.recoil + 0.2);
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const dx = enemies[i].x - player.x, dy = enemies[i].y - player.y;
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle(angleToEnemy - player.angle));
                if (angleDiff < 0.15) {
                    const hitDist = Math.sqrt(dx * dx + dy * dy);
                    if (hitDist < MAX_DEPTH) {
                        const paintColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
                        const hitColor = paintColors[Math.floor(Math.random() * paintColors.length)];
                        enemies[i].paintHits.push({ x: Math.random(), y: Math.random(), size: 3, color: hitColor });
                        enemies[i].health -= weapon.damage; enemies[i].color = hitColor;
                        const hitMarker = document.getElementById('hitMarker');
                        hitMarker.style.opacity = '1'; setTimeout(() => { hitMarker.style.opacity = '0'; }, 200);
                        break;
                    }
                }
            }
        }

        function updateAmmoDisplay() {
            const weapon = player.weapons[player.currentWeapon];
            document.getElementById('ammo').textContent = `üì¶ Ammo: ${player.ammo}/${weapon.ammo} | R: Reload`;
        }

        function updateWeaponDisplay() {
            const weapon = player.weapons[player.currentWeapon];
            document.getElementById('weapon').textContent = `${weapon.icon} ${weapon.name} [${weapon.damage} dmg]`;
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = 'Final Score: ' + score;
            console.log('Game Over - Score:', score, 'Wave:', waveNumber);
        }

        function startWave() {
            waveActive = true; waveEnemiesSpawned = 0; waveEnemiesDefeated = 0; player.killstreak = 0;
            const maxEnemies = 3 + (waveNumber * 2);
            document.getElementById('wave').textContent = `üåä Wave: ${waveNumber} | Enemies: 0/${maxEnemies}`;
        }

        function checkWaveComplete() {
            if (waveActive && waveEnemiesDefeated >= (3 + (waveNumber * 2))) {
                waveActive = false; waveNumber++;
                player.health = Math.min(player.maxHealth, player.health + 20);
                player.ammo = player.weapons[player.currentWeapon].ammo;
                document.getElementById('health').textContent = '‚ù§ Health: ' + Math.floor(player.health);
                updateAmmoDisplay(); score += 1000 * waveNumber;
                document.getElementById('score').textContent = 'Score: ' + score;
            }
        }

        function update() {
            if (!gameActive) return;
            movePlayer(); updateEnemies(); checkWaveComplete();
            if (!waveActive && enemies.length === 0) startWave();
        }

        function renderMinimap() {
            const minimapCanvas = document.getElementById('minimap');
            if (!minimapCanvas) return;
            const minimapCtx = minimapCanvas.getContext('2d');
            const mapScale = 15;
            minimapCtx.fillStyle = '#000'; minimapCtx.fillRect(0, 0, 150, 150);
            minimapCtx.fillStyle = '#444';
            for (let y = 0; y < 10; y++) for (let x = 0; x < 10; x++) if (levelMap[y][x] === 1) minimapCtx.fillRect(x * mapScale, y * mapScale, mapScale, mapScale);
            minimapCtx.fillStyle = '#FF0000'; enemies.forEach(e => { minimapCtx.beginPath(); minimapCtx.arc(e.x * mapScale, e.y * mapScale, 3, 0, Math.PI * 2); minimapCtx.fill(); });
            minimapCtx.fillStyle = '#00FF00'; minimapCtx.beginPath(); minimapCtx.arc(player.x * mapScale, player.y * mapScale, 4, 0, Math.PI * 2); minimapCtx.fill();
            minimapCtx.strokeStyle = '#00FF00'; minimapCtx.lineWidth = 1; minimapCtx.strokeRect(0, 0, 150, 150);
        }

        function gameLoop() {
            update(); render3D(); renderMinimap();
            requestAnimationFrame(gameLoop);
        }

        let spawnInterval = setInterval(() => {
            if (gameActive && waveActive && enemies.length < (5 + waveNumber) && waveEnemiesSpawned < (3 + waveNumber * 2)) {
                spawnEnemy();
                document.getElementById('wave').textContent = `üåä Wave: ${waveNumber} | Enemies: ${waveEnemiesDefeated}/${3 + waveNumber * 2}`;
            }
        }, 1500 - Math.min(waveNumber * 100, 700));

        setTimeout(() => { if (gameActive) startWave(); }, 1000);

        gameLoop();
        console.log('‚úì Game started! WASD=Move, Click=Shoot, 1-3=Weapons, R=Reload');
    </script>
</body>
</html>
